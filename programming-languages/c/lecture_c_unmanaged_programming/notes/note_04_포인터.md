# 포인터

이 문서는 Pope Kim [C 언매니지드 프로그래밍](https://www.udemy.com/course/c-unmanaged-programming-by-pocu/) 강의를 듣고 정리한 문서입니다.

## 포인터 (pointer)

- 하드웨어 처럼 메모리에 있는 변수에 직접 접근할 수 있을까? C에서는 포인터를 통해 가능하다.
- 이는 강력한 기능이기도 하지만 또한 위험한 기능이기도 하다. 따라서 잘 다룰 수 있도록 하자.

## 주소 연산자 &

- 지역 변수의 주소 출력하기

    ```c
    #include <stdio.h>

    void print_address(void)
    {
        int num = 10;
        printf("Address of num: %p\n", (void*)&num);
    }

    int main(void)
    {
        print_address();

        return 0;
    }

    ```

- 주소 연산자 &
  - 비트 연산자 &가 아니다. 비트 연산자는 언제나 피연산자가 두 개이다. 주소 연산자는 피연산자가 하나이다.
  - num이란 변수가 있으면 &num은 그 변수가 위치한 메모리 주소이다.
  - 보통 주소를 보여줄 때는 16진수를 사용한다. 읽기 편하기 때문이다.
  - 참고: 실행할 때마다 주소가 달라질 수 있다. 요즘 운영체제에서는 보안 강화를 위해 실행할 때마다 주소를 바꿔준다. 이를 ASLR 이라 부른다.

## 메모리 주소 저장하기

- 메모리 주소 자체를 어딘가에 저장해두면 더 좋지 않을까?
  - 어떤 데이터를 저장할 때 쓰는 것은? -> 변수
  - 메모리 주소도 변수에 저장할 수 있지 않을까?

- 주소: 값이 저장되어 있는 메모리 상의 위치 라는 표현이다.
- 값: 실제 산술 연산 등을 할 때 사용되는 것.

- 그냥 int 타입 같은 것에 주소를 저장하려고 하니 헷갈린다. 따라서 주소를 저장하기 위한 특별한 변수가 필요하다. 그 특별한 변수가 바로 `포인터`이다.

## 포인터의 의미

- 포인터: 주소를 저장하기 위한 변수형이다. 즉, 변수인데 속에 담긴 내용은 메모리 주소이다.

## 메모리 주소에 저장된 자료형

- 하드웨어는 자료형에 전혀 신경을 쓰지 않는다.
- 그러나 데이터를 읽을 때 해당 주소에서부터 몇 바이트를 읽어야 하는지는 하드웨어에게 알려 줄 필요가 있다.
- 그래서 포인터 변수를 선언할 때 포인터 앞에 자료형을 붙인다.
  - 어떤 메모리 주소가 있는데, 그 메모리 주소에 가서 선언한 자료형으로 자료를 읽어야 한다고 알려주는 것이다.

## 포인터 변수를 선언하는 방법

```c
void save_address(void)
{
    int num = 10;
    int* num_address = &num;
}
```

- 포인터 변수를 선언하려면 자료형 뒤에 별표(*)를 붙인다.
  - `int*`, `char*`, `float*`
- 별표(*) 위치가 어디에 있느냐는 언어에서 강제하지 않는다. `int *address;` 처럼 쓰는 경우도 있다.

## 포인터 변수를 부르는 방법

- 보통 `int* num_address` 에서 num_address를 int 포인터라고 부른다.
- 영어로는 int로의 포인터(pointer to an int)라고도 한다.

## 포인터에 저장된 주소도 바꿀 수 있나요?

- 당연히 바꿀 수 있다. 포인터도 변수이기 때문이다. 즉, 다른 주소로 바꿀 수 있다.

## 역 참조 연산자 *

- 포인터도 변수이다. 따라서 당연히 변수를 쓰는 곳에는 다 쓸 수 있다. 매개 변수로도 쓸 수 있다.

    ```c
    void print_address(int* num)
    {
        /* 주소 출력 */
        printf("address of num: %p\n", (void*)num);
    }

    /* 메인 함수 */
    int score = 88;
    print_address(&score);

    ```

    ```c
    /* 포인터에 저장된 값을 참조하는 예 */

    void print_value(void)
    {
        int score = 100;
        int* pointer = &score;

        printf("score: %d\n", *pointer);
    }

    void print_argument(float* arg)
    {
        printf("argument: %f\n", *arg);
    }

    ```

- 역참조 연산자 `*`
  - 곱하기 연산자가 아니다. 역 참조 연산자는 피연산자 1개를 가진다(곱하기 연산자는 2개).
  - 포인터 변수 앞에 `*`를 붙이면, 그 주소에 가서 값을 가져오라는 의미이다.

## 참조와 역 참조

- 역 참조라는 게 있으면...참조라는 게 있나?
- 참조라고 하는 것은 포인터가 이미 하고 있는 일을 말한다. 즉 어떤 변수의 값을 직접 가져다 쓰는 게 아니라 그게 어디에 있다고 '참조'하는 것이다. 즉, 값잉 어디에 있는지 가리키고 있는 것이다.
- 역 참조는 주소로 직접 가서 거기 저장되어 있는 값에 접근하는 것이다.
- 실제 데이터에 간접(indirect)적으로 접근한다는 의미이기도 하다. 주소를 이용해 접근한다.

## 역 참조를 이용한 값 변경 예

```c
void update_value(void)
{
    int score = 100;
    int* pointer = &score;

    printf("score: %d\n", *pointer);
    *pointer = 50;
    printf("updated score: %d\n", *pointer);
}

void update_argument(float* arg)
{
    printf("argument: %f\n", *arg);
    *arg = 93485.2f;
    printf("updated argument: %f\n", *arg);
}

```

- 포인터 변수 선언과 역참조를 헷갈리지 말자.
  - 이 헷갈림 때문에, 포인터 변수를 선언할 때 `int *v` 보다 `int* v`가 낫다.

## 포인터로 두 변수의 값 바꾸기

- C에 ref는 없지만 포인터가 있다!

```c
void swap(int* arg1, int* arg2)
{
    int tmp;

    tmp = *arg1;
    *arg1 = *arg2;
    *arg2 = tmp;
}

```

## 값에 의한 전달 vs 참조에 의한 전달

- 엄밀히 말하면 C는 값에 의한 전달이다. 함수를 호출할 때 언제나 변수를 복사한ㄷ. 단, 포인터를 사용해서 참조에 의한 전달을 흉내낼 뿐이다.
- 그런데 뭐...이런게 별로 중요하진 않다. 용어에 너무 의미를 두지 말자. 원본이 바뀌는지 안 바뀌는지가 중요하다. C에서는 포인터를 이용해 원본을 바꿔줄 수 있다.

## 포인터와 함수 반환 값

- 당연히 포인터도 변수니까 함수 반환 값으로 사용이 가능하다.
  - `int* do_something(const int op1, const int op2);`
- 다만 포인터를 반환할 때 조심해야 할 것이 있다.
- 매우 위험한 코드의 예

  ```c
  int* add(const int op1, const int op2)
  {
      int result = op1 + op2;
      return &result;
  }

  int main(void)
  {
      int* result;

      result = add(10, 20);

      return 0;
  }

  ```

  - 왜 위험할까?
    - 함수의 지역 변수는 스택에 저장된다. 함수의 호출이 끝나면 지역 변수도 사라진다. 위의 경우에 &result를 반환하고 함수를 나가면 스택 프레임 자체가 유효하지 않다. 그 값이 덮어쓰여 지기 전까지 값은 유효할 수 있으나 값의 유효함이 보장되지 않는다.

## 댕글링 포인터(dangling pointer)

(위의 경우와 이어지는 내용)

- 지역 변수가 사용한 '주소'자체가 사라지는 것은 아니다. 따라서 컴파일 오류가 나진 않는다. 문제는 포인터가 유효하지 않은 주소를 가리킨다는 것이다. 이러한 포인터를 `댕글링 포인터`라고 한다.
- 포인터를 반환할 경우 댕글링 포인터를 조심해야 한다.
  - 포인터를 반환해도 되는 경우
    - 전역 변수
    - 파일 속 static 전역 변수
    - 함수 내 static 변수
    - 힙 메모리에 생성한 데이터

    ```c
    int* spawn_monster(void)
    {
        static int s_monster_count = 0;

        /* some codes... */

        ++s_monster_count;

        return &s_monster_count;
    }

    ```

- 언제 포인터를 반환할까?
  - 도우미 함수 안에 생성한 변수를 다음 함수에서 사용하고자 할 때. 단, 일반 지역 변수면 안 된다.
  - 함수 안에서 대용량의 데이터를 생성하고 그걸 반환하고자 할 때.

## 널(NULL) 포인터

- 반환할 주소가 없는 경우에는 어떻게 해야할까?

```c
void do_something()
{
    int number;
    int* num_ptr = &number;

    /* some codes... */

    num_ptr = NULL;
}


```

- 아무것도 가리키지 않는 포인터를 널 포인터라고 한다.
- 값이 0인 상수 표현식이다.
- 또는 `(void*)`로 캐스팅된 표현식
- 전용 매크로가 있다.
  - `#define NULL ((void*)0)`
  - 널 포인터를 표현할 때 이 매크로를 사용할 것
- 포인터 변수와 NULL은 비교가 가능하다.

  ```c
  int* ptr;

  if (ptr == NULL)
  {
      /* some codes... */
  }

  if (ptr != NULL)
  {
      /* some codes... */
  }

  ```

- 0을 NULL로 사용하지 말자. NULL을 명시적으로 쓰자.

## NULL이 가지는 문제들

- 매개변수
  - 함수 매개 변수로 포인터가 들어올 때는 언제나 골칫 덩어리이다. 누구나 NULL을 넣을 수 있기 때문이다. 따라서 기본적으로 NULL이 안 들어온다고 가정하고 함수를 작성할 것. NULL이 들어올 수 있는 함수는 매개변수명에서 분명히 밝힐 것.
  - 널 포인터를 허용하는 매개 변수: 매개 변수 이름 끝에 '_or_null' 을 붙인다.

    ```c
    int get_score(const char* student_id_or_null)
    {
        /* some codes... */
    }

    ```

  - NULL이 안 들어온다고 가정한 경우 assert를 사용해 검증 한다.

    ```c
    #include <assert.h>

    #define PRICE (2)

    void increase_proce(int* current_price)
    {
        assert(current_price != NULL);

        *current_proce += PRICE;
    }

    ```

- 반환 값
  - NULL을 반환할 때도 골칫거리이다. 기본적으론 하지 않는다.
  - 반환을 해야 한다면 함수 이름에 NULL을 반환한다는 것을 명시하자.

  ```c
  const const* get_name_or_null(const int id)
  {
      /* 코드 생략 */ 
      return NULL;
  }

  ```

## 널 포인터는 언제 사용하나요?

- 포인터 변수를 초기화하고 싶을 때
  - 아직 참조할 주소가 없을 때.
    - `int* ptr = NULL;`
- 포인터 변수가 유효한 주소를 참조하고 있는지 확인하고 싶을 때
  - 아무것도 가리키지 않는 포인터 변수를 역참조하면? 결과가 정의되지 않음. 어떻게 될지 모른다.
    - `if (ptr != NULL) { ...`
- 댕글링 포인터를 막기 위해서
  - 동적 메모리 할당된 메모리를 더 이상 필요 없어서 해제했는데, 이를 여전히 가리키는 포인터가 있다면? 더 이상 사용할 수 없는 데이터이니 포인터 변수에 저장되어 있는 그 주소를 초기화해야 한다. 이 때 널 포인터를 이용해 리셋한다.

    ```c
    /* 동적 메모리 할당 */
    int* ptr = (int*)malloc(sizeof(int));

    /* 코드... */

    /* 더이상 ptr을 사용하지 않음 */
    free(ptr);
    ptr = NULL;

    ```

- 중요한 것! 존재하지 않는 메모리에서 값을 읽어오려고 하면 문제가 펑펑 터진다.

## 포인터의 비교

- 포인터 변수 자체를 비교하면 주소를 하는 거고 역참조를 통해 비교하면 값을 비교하는 것이다.
- 근데...NULL외의 주소를 왜 비교할까?
  - 변수 하나가 아니라 큰 메모리를 통째로 잡아두고 그 안에 복수의 데이터를 넣어 사용할 때 필요하다.
  - 배열!

## 포인터의 크기

- 모든 포인터는 동일한 크기를 가진다.
- 포인터의 크기는 코드를 컴파일하는 시스템 아키텍쳐에 따라 결정된다.
  - 보통 CPU가 한 번에 처리할 수 있는 데이터의 크기(=워드, word)와 동일하다.
- 포인터의 크기 예

```c
void print_pointer_size()
{
    char ch = 'c';
    int number = 934563;
    float pi = 3.1415f;

    char *char_ptr = &ch;
    int *int_ptr = &number;
    float *float_ptr = &pi;

    printf("char size: %d, char* size: %d\n", sizeof(*char_ptr), sizeof(char_ptr));
    printf("int size: %d, int* size: %d\n", sizeof(*int_ptr), sizeof(int_ptr));
    printf("float size: %d, float* size: %d\n", sizeof(*float_ptr), sizeof(float_ptr));
}

```

## 배열 포인터에 대입하기

- 가능하다.

## 배열 속 각 요소의 위치, 각 요소의 위치 계산하기

- 배열에서 각 요소 사이의 바이트 간격은 일정하다.
- 각 요소의 위치를 어떻게 계산할 수 있을까?
  - 첫 번째 요소의 주소와 자료형의 크기만 안나면 n번째 요소의 위치를 알 수 있다.
    - n 번째 요소 위치 = 첫 번째 요소 주소 + 자료형의 크기 * (n-1)
- 다음 요소 위치를 구할 때 주의할 점
  - 포인터에 정수 1을 더하는 것과 1바이트를 더하는 것을 헷갈리지 말자. 1바이트를 더하는 게 아니다.
    - 예를 들어 `int* ptr = nums; ptr = ptr + 3;`을 하면, int의 사이즈를 세 번 더한 것이다.

## 배열 요소에 포인터로 접근하기

- 다음과 같은 것들은 다 같은 것이다.
  - 재밌는 것은 배열의 첨자 연산자(`[]`)도 포인터에 쓸 수 있다.
  - `nums[1] == ptr[1] == *(ptr + 1)`
  - 컴파일러에게 모두 같은 의미이다.

```c
int nums[3] = { 10, 20, 30 };
int* ptr = nums;

printf("%d, %d, %d\n", nums[1], ptr[1], *(ptr + 1));

```

- 배열의 모든 요소 더하기 예제

```c
int sum(int* data, const size_t length)
{
    int result = 0;
    size_t i;
    for (i = 0; i < length; i++)
    {
        /* 방법 1 */
        result += data[i];
        /* 방법 2 */
        result += *(data + i);
    }
    return result;
}

```

## 포인터의 중간 정리, 포인터의 캐스팅

- C에서는 주소를 얻을 수 있는 방법이 딱 두가지이다.
  - 주소 연산자(&)
  - 배열의 이름: 배열의 시작 주소를 알려준다.
- 포인터에 정수 n을 더하거나 빼면 언제나 `(sizeof) * n`한 만큼 메모리 주소를 이동한다.
- 정말 딱 한 바이트만 옮기고 싶다면?
  - 한 바이트짜리 포인터로 캐스팅: `int_ptr = (char*)int_ptr + 1`;
- `int*` -> `char*` 캐스팅은 무엇을 캐스팅 하는 걸까?

## 딱 '한' 바이트만 옮기기

- `int*` -> `char*` 로 바꾸고 나면 실제 이 속에 있는 내용은 `char*`일까? 아니다.
- 그래서 프로그래머가 이상한 짓을 할 수 있다.

  ```c
  int int_array[] = { 27, 65 };
  int* int_ptr = int_array;

  int_ptr = (char*)int_ptr + 1;

  ```

## 두 주소 간의 사칙 연산

- 주소에는 정수만 더하거나 뺄 수 있다.
  - 소수를 더하거나 빼면 컴파일 오류가 발생한다.
- 두 주소 간에 사칙 연산은 뺄셈만 가능하다.
  - 두 주소를 더하고 나누고 곱하는 것은 의미가 없다.
  - 뺄셈은 그럼 무슨 의미일까?
    - 두 주소 사이에 들어갈 수 있는 데이터 수를 반환할 수 있다. 따라서 포인터가 아니라 정수를 반환한다.
      - `int sub = &nums[5] - %nums[1];`

## 포인터를 사용한 안전하지 않은 코드

```c
int i;

int num = 1024;
int nums[3] = { 34, 135, 49 };

int* ptr = nums;

/* 실수 1, i가 -1에서 시작(배열의 인덱스는 0부터 시작) */
/* 실수 2, 종료 조건이 3 이하가 아니라 3 미만이어야 한다. */
for (i = -1; i <= 3; ++i)
{
    printf("%p: %d\n", (void*)ptr + i, *(ptr + i));
}

```

- 이 코드를 실행하면 배열 외의 데이터에 접근하게 된다. 위험하다.
- 안전하지 않다고 안 쓰기엔 포인터는 너무 강력하다. 포인터 정도는 쓰자.

## 포인터와 배열의 차이

- sizeof 연산자
  - sizeof(배열)과 sizeof(포인터)는 서로 다른 값을 반환한다.
    - sizeof(배열): 배열의 총 크기를 반환
    - sizeof(포인터): 포인터의 크기를 반환

    ```c
    int nums[3] = { 34, 135, 49 };
    int* ptr = nums;

    size_t size1 = sizeof(nums); /* 12 = 3 x 4 */
    size_t size2 = sizeof(ptr); /* 4 */

    ```

- 문자열 초기화
  - C는 Java처럼 문자열(string) 자료형이 없다.
  - char 배열을 이용해서 문자열을 표현한다.
    - 가령 "Friday" 라는 단어를 저장한다면 총 6(+1)개의 요소를 가진 char 배열을 만든다. 문자열이 끝나는 지점을 알려주기 위해 널 문자(null character)라고 하는 특별한 문자를 항상 맨 마지막에 넣어 준다.
      - 널 문자: 값은 0으로 '\0' (백 슬래시(\)와 0을 합쳐서 표현)
    - 문자열을 초기화 하는 방법은 두 가지이다.
      - `char day1[] = "Monday";`
        - 배열에 차례대로 'M', 'o', 'n', 'd', 'a', 'y' 가 들어간 후 마지막에 '\0'가 들어간다.
        - 함수 안에서 사용하면 스택 메모리에 저장된다.
      - `char* day2 = "Monday";`
        - 포인터 변수는 스택에 저장 된다.
        - 실제 문자열은 데이터 섹션에 저장된다.
      - 스택에 저장된 문자열은 수정해도 괜찮지만 데이터 섹션에 저장된 문자열은 수정할 경우 '결과가 정의되지 않음'이다.
- 대입
  - 포인터 변수에는 값을 대입할 수 있었다.
    - `int* pointer1; int array1[5];`
    - `pointer1 = array1` => 가능
    - `array1 = pointer1` => 컴파일 오류
  - 그러나 배열 변수에는 할 수 없다.
- 산술 연산
  - 포인터는 산술 연산이 가능하지만, 배열은 불가능하다.
  - 배열의 주소를 증가하거나 감소하고 싶으면 포인터에 배열의 주소를 대입한 후 그 포인터 변수를 증가하거나 감소하면 된다.

## 다시 만나는 연산자 결합 법칙

- 익숙한 것들은 그냥 쓰고 아닌 것들은 괄호치는 것이 일반적이다.
- C에선 다른 언어에서는 안 봐서 익숙하지 않은 연산자 `*`, `&`가 있기 때문에 신경써야 한다.

## 포인터와 연산자 우선순위 및 결합 법칙

| 우선순위 | 연산자              | 연산자 결합 법칙 |
| -------- | ------------------- | ---------------- |
| 1        | ++ -- (후위 연산)   | ->               |
| 2        | ++ -- (전위 연산) * | <-               |

위의 표를 참고해서 알아보자

- `int num = *p++;` 는 `*(p++);` 와 같다.
  - p의 주소를 가서 읽어온다. 그걸 num에 대입한다. 그리고 p를 +1 한다.
- `int num = *++p;` 는 `*(++p);` 와 같다.
  - p를 하나 증가시킨 주소로 가서 값을 읽어온다. p를 먼저 증가시키고 거기 가서 값을 읽어와 num에 저장한다.
- `int num = ++*p;` 는 `++(*p);` 와 같다.
  - p에 접근 해서 값을 가져온다. 그리고 그 값을 num에 대입한다.
- `int num = (*p)++;` 는 명확하다.
  - p에 접근해서 값을 가져온 뒤 num에 대입한다. 그리고 거기에 1을 더해준다.

## 동일한 우선순위를 갖는 연산자들

- 동일한 우선 순위를 가지는 연산자들은 결합 방향이 다 같다.

## 조금 더 빠른 배열의 요소 더하기 함수

```c
int sum(int* start, int* end)
{
    int result = 0;
    int* p = start;

    while (p < end)
    {
        result += *p++;
    }
    return result;
}

/* 메인 함수 */
int nums[] = { 10, 20, 30, 40, 50 };
int result = sum(nums, nums + 5);

```

## 포인터와 const

- 변수의 수정을 막으려면 const를 써야 한다.
- 그런데 포인터의 const는 매우 헷갈린다. const로 보호해야 할 것들이 두 개가 있기 때문이다.

## 주소를 보호하는 const 포인터

- 기본 자료형 변수의 경우 const를 붙이면 그 변수에 저장한 값을 변경할 수 없다.
  - 보통 이게 반드시 필요하다고 느끼진 않는다. 실수가 발생해도 큰 문제가 발생하지 않기 때문이다.
- 포인터 변수에 const를 붙이는 건 무슨 의미일까? 메모리 주소이다.
  - 그래서 const 포인터는 메모리 주소를 바꿀 수 없다.
  - 그럼...`const int* a;` 라고 쓰면 되나? 아니다. 포인터 변수는 오른쪽에서 왼쪽으로 읽는다. 따라서, `int* const p = &num;` 이렇게 써야 한다. p는 const pointer 라는 의미이다.

## 값을 보호하는 const를 가리키는 포인터

- const 변수는 생성과 동시에 초기화해야 한다.
- const로 주소 변경을 막는 것이 아니라, 값 변경을 막을 수도 있을까?
  - 방법 1 `const int* p = &num1;`
  - 방법 2 `int const * p = &num1;`
  - 값 변경을 막는 것은 중요한 문제이다. 잘 신경쓰도록 하자.
  - 보통 방법 2가 더 말이 되어 이렇게 쓰일 것 같지만...방법1이 더 많이 쓰인다.

## 두 const의 정리와 예

- `int* const p = &num;`
  - 메모리 주소를 변경하는 것을 금지
- `const int* p = &num;`
  - 그 메모리 주소에 저장되어 있는 값을 변경하는 것을 금지

## 주소와 값 모두 지키는 const

- `const int* const p = &num;`
- 초기화 된 후 절대 바뀌지 않는 변수가 있을때 정도만 유용할 수 있지만, 생각보다 쓸 일이 많지는 않다.
- 주소에 저장되어 있는 값을 보호하는 const가 더 중요하다.

## const 포인터 읽는 방법 정리

- 값을 바꿀 수 없음
  - `const int* p = &num;`: p는 포인터인데, 무엇을 가리키냐면, int const(const int)
  - `int const* p = &num;`: p는 포인터인데, 무엇을 가리키냐면 const int
- 주소를 바꿀 수 없음
  - `int* const p = &num;`: p는 const 포인터인데, 무엇을 가리키냐면, int
- 둘 다 바꿀 수 없음
  - `const int* const p = &num;`: p는 const 포인터인데, 무엇을 가리키냐면 int const

## const는 절대 제거하지 말자

- 캐스팅을 통해 const를 없애줄 수도 있다. 그러나 그러지 말자.
- 기본 자료형에선 뭐...제거하는 게 큰 영향이 없을 수도 있다. 그러나 포인터에서는 절대 그러지 말자.

### const 베스트 프랙티스

- const는 최대한 다 붙이자.
- const는 캐스팅은 하지 말자.

## 포인터의 용도

- 큰 데이터를 함수의 매개 변수로 전달할 때.
  - 자료가 커질 수록 데이터를 복사하느라 시간을 낭비하게 된다. 그래서 배열이 매개변수로 전달될 경우, 첫 번째 요소의 주소를 전달한다.
- 반환 값이 둘 이상일 때.
  - return 문으로하는 값이 하나만 반환되어야 한다. 이럴 경우 포인터를 사용해 함수 안에서 원본을 변경해주는 방식으로 대체할 수 있다.
- 동적 메모리 할당
  - 함수의 범위에 상관없이 한동안 사용하고자 하는 데이터가 있는데, 다음과 같은 경우에 해당하면 사용한다.
    - 그 데이터의 크기를 컴파일 도중에 알 수 없거나
    - 프로그램 실핼 수명 보다는 짧은 시간 동안만 사용하려고 할 때
  - 동적으로 할당된 메모리는 역시 연속된 메모리 덩어리라 포인터가 적합하다.
- 데이터 구조를 표현할 때

## 포인터 배열

- 포인터를 저장하는 배열도 있다.
- `int*`를 담는 배열 선언: `int* num_pointers[3];`

## 2차원 포인터 배열

- 내부 배열의 길이를 알려주어야 한다.
- 함수에서 접근하려면 각 내부 배열의 길이를 알려주는 `size_t` 배열이 필요하다.

```c
void print_array(int* const data[], const size_t size, const size_t lengths[])
{
    size_t i;
    size_t j;
    const int* p;

    for (i = 0; i < size; ++i)
    {
        p = data[i];
        printf("nums[%d]:", i);

        for (j = 0; j < lengths[i]; ++j) 
        {
            printf(" %d", p[j]);
        }
        printf("\n");
    }
}

```

- 2차원 배열을 포인터를 이용해서 표현할 수 있을까?
  - 컴파일 오류가 나는 방법

    ```c
    /* 컴파일 오류 */
    void do_something(int *matrix[5])
    {
        /* do something ... */
    }

    int main(void)
    {
        int matrix[5][10] = ...
        do_something(matrix);
    }

    ```

  - 맞는 방법

    ```c
    /* m은 행의 수를 의미한다. */
    void do_something(int matrix[][10], size_t m)
    {
        /* do something ... */
    }

    int main(void)
    {
        int matrix[5][10] = ...
        do_something(matrix);
    }

    ```

- 2차원 배열은 어차피 한 덩어리 메모리라 주솟값이 저장된 곳이 없다. 위의 맞는 방법 처럼 표현해야 컴파일러가 매개변수가 2차원 배열이라는 것을 인지한다.
  - 그리고 컴파일러가 matrix[1][] 할 때 몇 개를 건너뛰어야 하는지 알 수 있다.

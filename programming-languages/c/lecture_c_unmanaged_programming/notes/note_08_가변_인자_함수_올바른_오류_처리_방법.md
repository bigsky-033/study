# 가변 인자 함수, 올바른 오류 처리 방법

이 문서는 Pope Kim [C 언매니지드 프로그래밍](https://www.udemy.com/course/c-unmanaged-programming-by-pocu/) 강의를 듣고 정리한 문서입니다.

## 가변 인자 함수

- 무언가 변할 수 있는 인자를 받는 함수라는 의미이다. 예를 들어 printf 같은 함수이다. 함수를 호출할 때 여러 개의 매개변수를 넣을 수 있다.
- 정해지지 않은 수의 매개변수를 허용하는 함수를 말한다. 반드시 최소 한 개의 정해진 자료형의 매개변수가 필요하다. 가변 인자는 `...`으로 표시된다.
- 가변 인자 함수의 선언
  - `<반환형> <함수명>(<자료형이_정해진_매개변수_목록>, ...);`
- 가변 인자 함수가 유용한 경우
  - printf, scanf 같은 경우
- 가변 인자 함수의 예

```c
#include <stdarg.h>

/* ... */

int add_ints(const size_t count, ...)
{
    va_list ap;
    int sum;
    size_t i;

    sum = 0;
    va_start(ap, count);
    {
        for (i = 0; i < count; i++)
        {
            sum += va_arg(ap, int);
        }
    }
    va_end(ap);

    return sum;
}

```

## va_로 시작하는 매크로 함수들

- va_list
  - 가변 인자 목록
  - `va_start()`, `va_arg()`, `va_end()` 매크로 함수를 사용할 때 필요한 정보가 포함된다.
- `va_start()`
  - `va_start(<가변 인자 목록>, <가변 인자 시작하기 직전 매개변수>);`
    - 매크로 함수이다.
    - 함수 매개변수로 들어온 가변 인자들(`...`)에 접근하기 전에 반드시 호출해야 한다. 얘를 호출하지 않고 접근하면 제대로 작동하지 않는다.
    - va_list에 필요한 초기화를 수행한다. 특히 가변 인자가 스택 메모리의 어디서부터 시작하는지를 찾아낸다.
- `va_end()`
  - 매크로 함수이다.
  - 함수 매개변수로 들어온 가변 인자들에 접근이 끝난 뒤에 반드시 호출해야 한다.
  - 사용했던 가변 인자 목록을 정리(clean up)한다. 이걸 호출한 뒤엔 더 이상 가변인자 목록을 사용할 수 없다.
- va_ 를 사용할 땐 중괄호를 이용해 가독성을 높이자. 반드시 필요한 건 아니지만 가독성을 높이고 실수를 방지하기 좋다.

```c
va_list ap;
va_start(ap, count);
{
    /* 코드 */
}

va_end(ap);

```

- `va_arg()`
  - `va_arg(<가변 인자 목록>, <얻어올 가변 인자의 자료형>);`
  - 매크로 함수이다.
  - 가변 인자 목록으로부터 다음 가변 인자를 가져온다.
  - 기본 자료형 중 모든 정수형은 int로, 모든 부동소수점은 double로 승격(promotion)된다.
    - 따라서, 두 번째 매개변수에는 int나 double를 쓴다.
- 당연히, 기본 자료형 말고 구조체도 가변 인자로 넣을 수 있다.
- 그러면...어떻게 가변 인자 목록에서 자료형을 읽는걸까?
  - C에서는 실행 중에 자동으로 자료형을 판단하는 기능이 없다. 따라서 컴파일러가 이와 비슷한 코드를 컴파일할 수 있게 준비해 주어야 한다.
    - 컴파일러가 볼 수 있는 코드를 미리 만들어주는 건 전처리기가 한다. va_arg() 같은 게 매크로 함수이다.
      - va_arg() 는 함수처럼 보이지만 엄밀한 의미의 함수는 아니다.
        - 스택 프레임을 만들지도, 매개변수를 전달하지도 그리고 함수 주소를 점프하지도 않는다.
        - 대신 전처리기가 매크로 함수의 구현 코드로 대체해준다.

## 가변 인자 함수가 인자를 읽어오는 방법

1. `va_start(ap, count)`에서 가변 인자 시작 직전 매개변수에 기초해서 가변 인자 목록의 시작 주소를 계산한다.
2. `va_arg(ap, int);`가 호출될 때마다 `int 크기만큼 더해가며 읽을 위치를 변경하게 된다.

## 함수에서 매개변수로 가변 인자만 받을 수 있을까?

- `int add_ints(...);` 같은 것을 쓸 수 있을까?
  - 안된다. 왜 안될까?
    - 가변 인자 함수에서 안 되는 것
      - 가변 인자(...) 앞에 자료형이 특정된 매개 변수가 반드시 있어야 한다.
      - 가변 인자 뒤에 자료형이 정해진 매개변수가 있어도 안 된다. 함수가 정확히 어느 오프셋에서 읽어와야 하는지 컴파일 중에 특정이 불가능하기 때문이다.

          ```c
          void do_something(..., int) /* 컴파일 오류 */
          void do_something(int, ..., int) /* 컴파일 오류 */
          void do_something(int, int, ...) /* OK */

          ```

      - 즉 가변 인자가 아닌 것을 우선 차례대로 읽는다. 그 뒤, 가변 인자는 va_arg()가 시키는 대로 주소를 늘려가며 읽는다.
    - 왜?
      - 실제 가변 인자가 몇 개 들어왔는지 호출된 함수는 모른다.
      - 가변 인자의 자료형을 가변 인자 함수는 모른다. 실행 시점에 결정된다. 따라서 정해진 자료형으로 넘겨주는 매개 변수로부터 알아내야 한다.
        - printf()에서 첫 번째 매개변수는 변환 문자열이다. 이 문자열이 가변 인자 함수가 알지 못하는 정보들을 알려준다. 몇 개 가변 인자가 들어올지, 각 인자의 자료형이 무엇일지 알려준다.

## 오류 처리

- C 언어는 예외(exception)을 지원하지 않는다. 그럼 C에서는 실행 중에 생기는 문제들을 어떻게 처리할까?
  - 문제들을 제대로 처리하지 않으면 크래시가 난다.

## 버그와 오류의 차이, 올바른 오류 처리 전략

- 버그
  - 일어날 수 없다고 가정한 상황이다. 즉, 선조건(precondition) 및 후조건(postcondition)이 성립하지 않고 어서트(assert)가 실패하는 경우.
    - 어서트의 문제는 실행해야만 보인다는 것이다. 단, c11은 정적 어서트(static assert)로 이러한 한계를 극복한다.
  - 프로그램이 이런 상황에서도 올바르게 작동하게 두는 건 말이 안 된다. 그냥 이 버그가 다시는 일어나지 않게 코드를 수정해야 한다.
- 오류
  - 실제 실행 중에 일어날 수 있는 예측 가능한 상황들이다. 프로그램이 잘 대처해야 한다.

- assert 예

    ```c
    unsigned int deposit(unsigned int deposit_mount)
    {
        unsigned int before_total;
        unsigned int after_total;

        /* precondition */
        assert(deposit_mount > 0);

        /* codes... */

        /* post condition */
        assert(before_total < after_total);

        return after_total;
    }

    ```

- 실행 중 오류 처리는 어떻게 해야 잘 처리하는 것일까?
  - 유효하지 않은 데이터가 들어오면 어디선가 걸러주어야 한다. 어딘가를 '경계'(boundary)라고 부른다.
    - 경계의 예
      - 내 프로그램 <-> 파일 시스템
      - 내 프로그램 <-> 키보드 입력
      - 내 프로그램 <-> 외부 라이브러리 (3rd-party library)
- 예) 널 포인터를 허용한다면 함수나 변수에 명시

    ```c
    monster_t* spawn_monster_or_null(const monster_t* special_monster_or_null)
    {
        /* codes */
    }
    
    ```

- 예) 오류 코드를 반환한다.

    ```c
    libabc_error_t try_get_student(int id, student_info_t* out_student)
    {
        size_t idx;
        /* codes... */
        if (idx == -1)
        {
            return ERROR_STUDENT_NOT_FOUND;
        }
        /* codes... */
        return ERROR_NONE;
    }

    ```

- (C에서) 모든 오류 코드를 하나의 enum으로 만들자. 함수마다 오류 enum을 만드는 건 좋지 않다. C의 enum은 서로 비교 및 대입이 가능하기 때문이다.
- errno에 저장하는 것도...딱히 훌륭한 방법은 아니다. 함수가 errno을 세팅하는지 코드나 문서를 읽어보지 않는 한 모른다.
- 정리
  - 기본적으로 내가 작성하는 모든 함수에 들어오는 데이터는 유요하다고 가정하고 어서트를 많이 쓸 것
  - 그렇지 않은 함수는 매개변수나 함수 이름에서 그렇지 않다는 사실을 명백히 표시할 것
  - 오류 상황을 처리하는 장소는 최소한으로 할 것
  - 어떤 함수가 오류 처리를 한다는 사실을 반환형 등을 통해 확실히 보여줄 것

# C언어 기본 문법 2, 빌드 단계

이 문서는 Pope Kim [C 언매니지드 프로그래밍](https://www.udemy.com/course/c-unmanaged-programming-by-pocu/) 강의를 듣고 정리한 문서입니다.

## 함수

- C 언어 함수 맛보기

    ```c
    #include <stdio.h>

    static float s_gas = 500.f;

    void honk(void)
    {
        printf("Honk~ honk~);
    }

    void reduce_gas(float consumed_gas)
    {
        s_gas -= consumed_gas;
    }

    ```

- C는 접근 제어자(public, private 등)가 없다.
- C의 함수는 기본적으로 모두 전역(global) 함수이다.
- 함수 오버로딩도 존재하지 않는다. 따라서 필요할 경우 함수 이름을 다르게 만들어야 한다.
- C는 언제나 위에서 아래로 코드를 본다. ANSI C(C89)에서 함수 정의가 등장하기 전 그 함수를 호출하면 컴파일러가 다음과 같이 가정한다.
  - 반환형은 int
  - 매개 변수는 아무 것이나 올 수 있다.
  - 따라서 나중에 컴파일러가 int가 아닌 다른 것을 반환하는 함수를 찾으면 컴파일 오류를 발생시킨다.

## 함수 정의의 문제

- 위에서 본 문제를 해결하기 위해서 그러면...호출하는 코드 위에 전부 함수를 위치시켜야 할까? 다행히 그렇지는 않다. 아래에 나오는 함수 선언이 이런 문제를 해결해 준다.

## 함수 선언

- 함수의 구현체 없이 함수 원형(prototype)만 선언해 주는 것이다.
  - 원형이란?
    - 함수의 이름
    - 반환형
    - 매개 변수들의 자료형
      - 매개 변수 이름은 없어도 된다. 단, 가독성을 위해 일반적으로 변수 이름도 넣는 게 좋다.
  - 함수 정의(definition)은 실제로 함수를 구현해놓은 것이다.
    - 당연히, 함수 정의는 함수 선언이기도 하다.

```c

/* 함수 선언과 정의를 분리 */

#include <stdio.h>

void foo(void);

int main(void)
{
    foo();
    getchar();
    return 0;
}

void foo(void)
{
    printf("foo called");
}

/* 함수 선언과 정의가 하나 */

#include <stdio.h>

void foo(void)
{
    printf("foo called");
}

int main(void)
{
    foo();
    getchar();
    return 0;
}

```

- 함수를 선언한다는 것은 함수를 사용하기 전에 그 함수를 선언한다는 것이다. 보통은 파일의 제일 위에 선언한다.
  - forward declaration(전방 선언) 이라는 표현으로 많이 쓴다.
- 또는 헤더 파일에 넣을 수도 있고 이게 더 좋은 방법이다.
- 전방 선언의 작동 원리
  - 컴파일 시 실제 어디로 가서 코드를 찾아야 하는지는 모르니 구멍으로 둔다.
  - 컴파일 다음 단계인 링크(link) 단계에서 실제 코드 위치를 찾아서 그 구멍을 채운다.
- C89 표준에서 기본적으로 가정하는 사항을 충족하는 경우(int 를 반환하는 함수)에는 함수 선언을 하지 않아도 될까?
  - 그러지 말자. 함수 선언은 언제나 하도록 하자.
  - C99 표준부터는 int라는 가정을 하지 않는다.
  - 어떤 컴파일러는 경고만 주고, 컴파일은 허용할 수도 있다.
  - 모든 컴파일러가 그렇단 보장이 없다.

## 함수 매개변수 평가 순서, 피연산자 평가 순서

- 실수할 가능성이 높은 부분이다. 주의해서 보도록 하자.

```c
#include <stdio.h>

int add(int op1, int op2)
{
    printf("add()\n");
    return op1 + op2;
}

int subtract(int op1, int op2)
{
    printf("subtract()\n");
    return op1 - op2;
}

int main(void)
{
    int num1 = 128;
    int num2 = 256;

    printf("%d, %d\n", add(num1, num2), subtract(num1, num2));

    return 0;
}

```

- 위의 코드는 어떤 순서로 출력이 될까? => 모른다.
  - 경우 1) add()가 먼저 평가
  - 경우 2) subtract()가 먼저 평가
- 표준에 따르면, 함수 매개 변수의 평가 순서는 명시되어 있지 않음(unspecificed)
  - undefined 와 unspecificed 는 다르다. unspecified는 문제에 대해 가능한 경우의 수를 정의는 해 놓는다. 단 그 경우의 수 중 어떤 것이 옳은지는 정의하지 않는다.
- 즉, 컴파일러에 따라 평가 순서가 달라질 수 있다.
- `printf()`가 실제로 실행되기 전에 `add()`와 `subtract()`가 실행가 실행되는 것은 보장된다. 단, add와 subtract 중 어떤 것이 먼저 실행될지는 보장하지 않는다. 컴파일러에 따라 다를 수 있다는 말이다.
- 따라서 같은 라인에서 왼편에 있는 함수가 먼저 실행될 것이라 가정하고 코드를 짜는 것은 버그를 유발할 수 있다.
  - 예를 들어, 두 함수가 같은 변수를 사용(read/write)하고 호출 순서에 의존적이라고 할 경우, 컴파일러에 따라 함수 실행 순서가 달라질 수 있고 의도와는 다른 결과를 만들 수 있다.

```c
#include <stdio.h>

float divide(int op1, int op2)
{
    printf("%d / %d = ", op1, op2);
    return op1 / (float) op2;
}

int main(void)
{
    int num = 0;
    float result = divide(++num, ++num);
    printf("%f\n", result);

    return 0;
}

```

- 그렇다면 위의 코드는 실행 결과가 어떻게 될까? => undefined behavior
  - 첫 번째 인자가 먼저 평가될 경우
  - 두 번째 인자가 먼저 평가될 경우
  - 동시에 평가될 수도 있다.

- 기본적으로 한 줄에서 동인한 변수를 여러 번 바꾸면 위험하다.
  - 함수 매개 변수의 평가 순서는 컴파일러마다 다를 수 있다.
  - 한 함수의 매개 변수들이 동일한 변수를 수정할 경우, 결과가 정의되지 않음(undefined behavior)
  
  ```c
  /* 위험한 것들 */
  add(++i, ++i);
  add(i = -1, i = -1);
  add(i, i++);
  ```

- 정의되지 않은 것은 하지말자. 위험하다.
- `+` 연산자는 피연산자의 평가 순서를 강제하지 않는다. `=` 연산자도 마찬가지이다.

## 연산자 우선순위와 평가 순서

```c
int main(void)
{
    int num1 = 10;
    int num2 = 20;

    int result = add(num1, num2) + subtract(num1, num2) * divide(num1, num2);
    printf("result: %d\n", result);

    return 0;
}
```

- 주의하자. 함수의 평가 순서와 연산자 우선 순위는 아무런 관련이 없다. add, subtract, divide 무엇이 먼저 평가될 지는 알 수 없다.

## 평가 순서를 강제하는 연산자

- sequence point, <https://en.wikipedia.org/wiki/Sequence_point> 에 대해 읽어보도록 하자.
- short circuit 평가도 평가 순서를 강제하는 연산자 중 하나이다.
  - 논리 연산자 &&와 ||는 평가 순서를 강제하는 연산자이다.
  - 왼쪽 피연산자의 평가만으로 오른쪽 피연산자를 평가 안 할 수 있다.
- 정리하자면, 한 줄에 있는 여러 피연산자들은 기본적으로 평가 순서가 보장 안 된다고 생각하자.
  - short circuit, 삼항 연산자 정도만 예외적으로 알아두자.

## 범위(scope)

- 블록 범위
  - 중괄호({}) 안에 선언한 것들은 그 블록 안에서만 사용 가능하다.
  - 블록 안에 또 다른 블록을 넣을 수도 있다. 그러면 안쪽 블록은 바깥 블록에는 접근이 가능하지만 그 반대는 안 된다.
    - c에서는 변수 선언 위치의 제약 때문에 블록이 조금 특별한 의미를 갖는다. 아래의 예를 보자.

    ```c
    int main(void)
    {
        int num1 = 10;
        printf("num: %d\n", num1);

        {
            /* c에서는 변수 선언 위치에 제약이 있다. 이렇게 블록 안에서 선언하면 괜찮다. */
            int num2 = 100;
            int result = num1 + num2;
            printf("result: %d\n", result);
        }

        /* num2, result 접근 못 함 */
    }

    ```

  - 변수 이름 가리기(variable shadowing) 금지. 가독성 뿐만 아니라 버그를 만들 가능성이 높다. 변수 이름 가리기는 블록 안에서 블록 밖에 있는 변수와 같은 이름의 변수를 선언하고 사용하는 것을 말한다.

  ```c
  /* 안 좋은 코드 */
  int main(void)
  {
      int num = 0;
      printf("%d", num);
      {
          int num = 1; /* variable shadowing */
          printf("%d", num);
      }

      return 0;
  }

  ```

- 파일 범위
  - 어떤 블록이나 매개 변수 목록에도 안 속하고 파일 안에 있는 것을 말한다.
  - 엄밀하게 말하면 translation unit이다. 이것에 대해서는 나중에 더 배울 것이다.

  ```c
  # include <stdio.h>

  /*  파일 범위 */
  static int s_num = 1024;

  int add(int op1, int op2);

  int main(void)
  {
      s_num = add(10, 30);

      return 0;
  }
  ```

  - 파일 범위에 있는 변수는,
    - 다른 소스코드 파일에서 링크 가능
    - 프로그램 실행 동안 공간을 차지한다.
      - 즉, 스택 메모리에 들어가는 것이 아니다.
      - 데이터 섹션에 들어간다.
  - 이게 바로 전역 변수이다.
- 함수 범위
  - 유일한 예: 레이블(label)
  - goto 같은 데서 쓰는 것이다.
  - 함수 안에서 선언된 레이블은 함수 어디에서라도 접근 가능하다.
  
  ```c
  int main(int argc, char** argv)
  {
      if (argc != 3) {
        goto exit;
      }

      printf("You have 3 arguments!");
  
  exit:
      return 0;
  }
  ```

- 함수 선언 범위
  - 함수 선언의 매개 변수 목록에 있는 것은 그 목록 안에서 접근이 가능하다.
  - 많이 쓰일 일은 없지만 알아두자.

  ```c
  /* 괜찮은 예제들 */
  void so_something(
      double value,   /* 함수 선언 범위 */
      char array[10 * sizeof(value)] /* value는 첫 번째 매개변수 */
  )
  ```

## const 키워드

- 이름 달린 상수를 만들어 주기 좋다.
- 실수를 방지하기 좋다.

```c
/* 예 1) const 때문에 밑에서 id를 바꾸려는 시도를 하면 컴파일 에러가 난다. */
int calculate_risk(const int id) 
{
  /* ... */

  id *= 2; /* 컴파일 오류 */

  /* ... */
}

/* 예 2) const 때문에 밑에서 id를 바꾸려는 시도를 하면 컴파일 에러가 난다. */
void update_dimenstion(int w, int h, int data[])
{
    const int area = w * h;

  /* ... */

    area = area + 1; /* 컴파일 오류 */

  /* ... */
}

```

- const best practice
  - 기본적으로 모든 변수에 const를 붙이자.
  - 정말 값 변경이 필요한 변수에만 const를 생략하자.

## goto 문

```c
goto <label_name>;
...

<label_name>:

```

- C는 위에서 아래로 순차적으로 코드를 실행하는 언어이다. 그런데 `goto`를 쓰면 이 순서를 어기고 다음에 실행할 코드를 마음대로 지정이 가능하다.
  - 같은 함수 내에 있는 레이블(label)로 점프한다.

- goto의 나쁜 예

```c
void do_work(void)
{
infinity:
    printf("work time!\n");

    goto infinity;
}

```

- 반복문은 결국 goto를 사용하는 코드이다.

## goto 문은 정말로 악마인가요?

- 기본적으로는 좋지 않다. 실수/버그를 만들기 쉬운 코드이기 때문이다.
- 그러나 때때로 goto를 써서 코드가 간결해지는 경우도 있다. 중첩된 for문에서 중간에 종료하고자 하는 경우, goto를 이용하면 코드가 많이 간결해진다.

```c
for (i = 0; i < DEPTH; ++i) {
    for (j = 0; j < HEIGHT; ++j) {
        for (k = 0; k < WIDTH; ++k) {
            if (data[i][j][k] == 1) {
                printf("%d", data[i][j][k]);
            }
            else {
                goto loop_exit;
            }
        }
    }
}

loop_exit:
  /* code */
```

- goto best practice
  - goto 문은 언제나 전방(아래쪽)으로만 점프할 것. 위로 점프하면 코드가 꼬이기 쉽다.
  - nested loop에서 빠져나올 때는 자유롭게 쓸 것.
  - 한 함수 안에 있는 여러 개의 조건문이 공통된 코드를 실행해야 할 때는 괜찮다.
    - 예) 함수 마지막에 성공/오류 조건 처리
  - 단, 같이 일 하는 프로젝트에서 goto를 좋아하지 않는 사람이 있다면, 안 쓰는 게 낫다.

## 배열

- 반드시 new를 사용할 필요가 없다.

```c
int nums[5];
char name[10];
float GPAs[3] = { 3.1f, 2.2f, -13.f };

```

- 접근 방법은 여타 다른 언어와 비슷하다.

## 스택 메모리

- C는 값형으로도 배열을 만들 수 있다.

### 스택 메모리란

- 자료 구조인 스택이랑 헷갈리지 말자. 작동 방법이 동일해서(LIFO) 스택이란 이름을 사용할 뿐이다.
- 각 함수에서 사용하는 지역 변수 등을 임시적으로 저장하는 공간이다.
- 스택 메모리의 크기는 프로그램 빌드 시에 결정 된다.
- 스택 메모리의 위치는 실행 시에 결정된다.
- 스택 메모리가 어떻게 쓰이는 지 좀 풀어 설명해 보자. 어떤 함수가 호출되면 그 함수 실행을 위해 메모리 공간이 필요하다. 그 때 필요한 공간을 스택에서 떼어준다(이 공간은 마음대로 쓰라고 한다). 그리고 그 함수가 종료되면 다시 그 공간의 소유를 회수한다.

- 기본 자료형 변수는 모두 스택 메모리를 차지한다.
  - Java 같은 곳에서 기본 자료형 변수(char, int, float...)를 `new` 없이 사용할 수 있었던 이유는 스택 메모리에 할당 되었기 때문이다.
  - 기본 자료형을 함수 매개 변수로 전달하면 스택에 복사본을 만든다. 이게 바로 값형이다.
  - 스택 메모리를 빌리고 반환할 때마다 언제나 빈 공간 없이 차곡차곡 쌓여 있다.
  - Java 같은 곳에서 `new` 로 만든 데이터는 힙(heap) 메모리에 할당된다.

## 스택 메모리에 대해서 간단히 알아보자

- 스택은 큰 주소에서 작은 주소로 쌓인다.
- ESP(Extended Stack Pointer): 현재 스택 포인터.
- EBP(Extended Base Pointer): 현재 스택 프레임의 기본(첫) 주소, 현재 함수가 사용하고 있는 스택 공간의 시작 부분.
- 즉, EBP ~ ESP 가 현재 내 함수가 사용하고 있는 스택 메모리 공간. 스택 프레임(Stack Frame, 각 함수가 사용하는 스택 메모리의 범위)이라고도 한다.

## 스택 메모리 안의 배열, 스택 오버플로

- 변수 대신 배열을 넣으면 어셈블리어 에선 어떻게 될까? 배열을 위한 만큼의(정확히는 조금 더 잡힐 수 있음) 메모리가 추가로 잡힌다.
- OS에서 할당해주는 메모리를 이용하는 것 보다 이렇게 스택을 사용하는 게 빠르다. 스택을 사용하면, 그냥 정해진 메모리에어 위아래로 왔다 갔다 하면 된다. 새로운 메모리를 찾아달라고 OS에게 요청할 필요가 없다.
- 스택의 크기는 한정적이지 않나?
  - 맞다.
- 쓰레드 마다 스택은 따로 생긴다. 쓰레드 별로 호출 스택이 따로 생긴다.
- 스택 오버플로우
  - 스택의 크기가 약 1MB일 때, 아래와 같은 코드를 실행하면, 곧바로 스택 오버플로우 에러가 난다.
  
  ```c
  int add(const int a, const int b)
  {
      char buffer[1024 * 1024];
      int res = a + b;
      return res;
  }

  ```

  - 너무 큰 데이터를 스택에 넣으려 하면 안 된다. 큰 데이터를 사용할 때는 동적 메모리를 할당해야 한다.
  - 재귀 함수를 너무 깊게 호출하면 스택 오버플로우가 발생할 수 있다. 함수를 한 번 호출할 때마다 그 함수의 스택 프레임만큼 바이트를 더 먹게 된다. 그 함수가 반환하지 않고 계속 다른 함수를 호출하며 스택을 올리다보면, 언젠가 스택 공간을 다 쓰게 된다. 그러다 스택 오버플로우가 발생한다.

## 배열의 요소 개수 구하는 방법

```c
int values[30];
size_t array_size = sizeof(values); /* 120 */

```

- sizeof(values)는 values 배열이 차지하는 총 바이트 수를 반환한다. 배열이 스택에서 몇 바이트를 차지하는 지 컴파일 중에 알 수 있기 때문이다.
- 배열의 요소 개수를 구하는 방법
  - 1) `const size_t num_vals = sizeof(values) / sizeof(values[0]);`
  - 2) 매크로 함수를 이용해 좀 더 쉽게 만들 수도 있다.

    ```c
    /* 함수 밖에서 */
    #define ARRAY_LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))

    /* 매크로 함수 사용 */
    const size_t num_vals2 = ARRAY_LENGTH(values);

    ```

- sizeof(매개변수)와 배열의 총 바이트 수
  - sizeof()가 매개변수로 들어온 배열의 총 바이트 수를 반환할 수 있으려면 그 배열의 모든 요소가 스택에 다 복사되어 전달되어야 한다.
  - 그리고 호출되는 함수는 스택에 복사된 모든 요소의 크기를 정확히 알 수 있어야 한다.
  - 즉 이 말은, 두 함수 호출에서 매개 변수 전달에 사용하는 스택의 크기가 달라야 한다는 말이다. 말이 안 된다.
  - 함수의 스택 메모리 사용량은 고정이다. 함수는 호출자가 누구든 간에 딱 정해진 수와 크기의 매개 변수가 들어온다는 가정으로 동작한다. 함수가 먼저 결정되는 것이고 호출자는 그 함수를 호출할 뿐이다.
  - 따라서, 배열을 매개 변수로 전달할 때는 실제 모든 요소를 스택에 넣지 않는다. 대신 그 배열의 시작 위치(주소)를 스택에 넣어 준다. sizeof(매개변수)가 4를 반환했다면, 주소의 크기(포인터 데이터 형의 크기)를 반환한 것이다.
    - 32비트 플랫폼에서는 4바이트, 64비트에서는 8바이트

## 길이가 명시된 매개변수 배열

```c
void process(int nums[5])
{
    size_t i;
    for (i = 0; i < 5; ++i)
    {
        num[i] *= 2;
    }
}

```

- 여기서 배열의 크기([5])는 그냥 프로그래머가 읽기 편하라고 [5]를 써 준 것이다.
- 컴파일하면 `void process(int nums[])`와 동일하다.

## 매개변수 배열의 길이, 배열 요소의 초기값

- 매개변수 배열의 길이를 알 수 있는 방법은 없다. 즉, 배열의 크기는 따로 기억해둬야 한다.

```c
void process(size_t n, int nums[])
{
    size_t i;
    for (i = 0; i < n; ++i)
    {
        nums[i] *= 2;
    }
}

```

- C는 배열 요소의 값을 초기화해주지 않았다. 따라서 그 전에 그 메모리에 남아있던 값을 그대로 사용한다. 이걸 초기화해주지 않고 사용하면 문제가 될 가능성이 많다. 변수도 마찬가지이다.
- 여기서 보면 C의 특징을 알 수 있다. 다른 언어와 비교했을 때 언어 자체에서 안전하라고, 또는 편의를 위해서 해주는 기능이 많이 없다. 이런 부분에서 다른 언어와 성능의 차이가 날 수 있다. 다만 유의해야 한다.
- 배열 요소를 초기화 하는 방법

```c
int nums1[4];   /* 쓰레기 값이 들어가 있음 */
int nums2[4]  = { 10, 15, 3, -1 };  /* 모두 초기화 됨 */
int nums3[4] = { 10, 15 };    /* 10, 15, 0, 0 으로 뒤는 0으로 초기화 됨 */
int nums4[2] = { 10, 15, 3 }; /* 컴파일 오류 */
int nums5[] = { 10, 15, 3}; /* 배열의 크기 = 3, 컴파일러가 배열의 크기를 결정 */

```

- 베스트 프랙틱스: 배열의 모든 값을 0으로
  - `int nums[10] = { 0, }`;
  - 가독성을 위해 0 뒤에 쉼표를 찍자.
- 초기화 안 된 지역 변수, 버퍼 오버플로 등을 유의하자.

## 다차원 배열

- 다차원 배열은 2차원이나 3차원 배열 같은 것이다.

```c
int table[2][3];
size_t i;
size_t j;

for (i = 0; i < 2; ++i)
{
    for (j = 0; j < 3; ++j)
    {
        table[i][j] = (i + 1) * (j + 1);
    }
}

```

- 아래의 두 배열은 같은 것이다. 2차원 배열은 실제로 메모리에 일렬로 배열된다.

```c
/* 1 */
int buffer[3][2];
int i;
int j;

for (i = 0; i < 3; ++i)
{
    for (j = 0; j < 2; ++j)
    {
        buffer[i][j] = 0;
    }
}

/* 2 */
int buffer[3 * 2];
int i;
int j;

for (i = 0; i < 3; ++i)
{
    for (j = 0; j < 2; ++j)
    {
        buffer[i * 2 + j] = 0;
    }
}

```

## 소스코드에서 실행파일까지, C 프로그램의 빌드 과정

- 빌드(build)란 무엇인가?
  - 사람이 읽기 쉽게 쓴 소스코드를 기계어 명령어로 변환하는 과정
  - 그리고 그 명령어들을 모아 기계에서 실행 가능한 실행 파일로 만드는 과정
- C의 빌드는 4단계로 나뉘어 있다.
  - 전처리(preprocessing)
  - 컴파일(compilation)
  - 어셈블(assembling)
  - 링크(linking)
    - 전처리, 컴파일, 어셈블을 합쳐서 컴파일이라고 부르기도 한다.

- 소스코드(.h, .c) -> `전처리기` -> 확장된 소스 코드(트랜스레이션 유닛)
- 확장된 소스 코드(트랜스레이션 유닛) -> `컴파일러` -> 어셈블리 코드
- 어셈블리 코드 -> `어셈블러` -> 오브젝트 코드
- 오브젝트 코드 -> `링커` -> 머신 코드 실행 파일(.exe, .out)

- clang에서는 한 번의 명령어로 했는데?
  - clang이 모든 4단계를 한 번에 실행해 준 것이다.
  - clang에서도 당연히 한 단계씩 따로 실행할 수 있다.

## .h와 .c 파일

### C파일(.c)

- 실제 프로그램을 돌게 하는 로직 코드를 저장해두는 파일.
- 함수의 정의, 함수의 구현, 전역 변수 매크로 등을 정의한다.

### 헤더 파일(.h)

- 여러 소스코드 파일에 공통으로 필요한 것들을 저장해두는 파일.
- 함수 선언, 매크로, extern 변수 선언 등을 포함한다.
- 사용 하려면 #include로 포함한다.

## 헤더 파일이 필요한 이유

- 모든 소스 코드를 .c 파일 하나에 집어 넣을 수도 있다. 근데 그렇게 하지 말자...
- 동일한 함수를 여러 곳에서 써야 한다면? 복붙을 해야 할까?
  - 그렇게 하지 말자...
- 헤더 파일을 사용하면 함수 선언을 여러 C 파일들에서 공유해 사용할 수 있다.

## #include <>와 #include ""

## 빌드 과정: 전처리 단계

## 트랜슬레이션 유닛 보는 방법

## 빌드 과정: 컴파일 단계

## 어셈블리어 코드 보는 방법

## 빌드 과정: 어셈블 단계

## 오브젝트 코드 보는 방법

## 빌드 과정: 링크 단계

## 링크 단계가 분리되어 있는 이유

## 라이브러리(library), 정적/동적 라이브러리와 링크

## 분할 컴파일과 전역 변수

## 다른 파일에 있는 전역 변수 사용 시 문제점

## extern 키워드

## 전역 변수의 문제, static 키워드

## .c와 .h 파일 정리, 순환 헤더 인클루드와 해결법

## 인클루드 가드 작동법

## 인클루드 가드 예제

## C 컴파일러의 종류와 특징

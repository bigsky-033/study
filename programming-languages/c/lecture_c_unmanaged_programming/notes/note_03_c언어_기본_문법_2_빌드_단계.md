# C언어 기본 문법 2, 빌드 단계

이 문서는 Pope Kim [C 언매니지드 프로그래밍](https://www.udemy.com/course/c-unmanaged-programming-by-pocu/) 강의를 듣고 정리한 문서입니다.

## 함수

- C 언어 함수 맛보기

    ```c
    #include <stdio.h>

    static float s_gas = 500.f;

    void honk(void)
    {
        printf("Honk~ honk~);
    }

    void reduce_gas(float consumed_gas)
    {
        s_gas -= consumed_gas;
    }

    ```

- C는 접근 제어자(public, private 등)가 없다.
- C의 함수는 기본적으로 모두 전역(global) 함수이다.
- 함수 오버로딩도 존재하지 않는다. 따라서 필요할 경우 함수 이름을 다르게 만들어야 한다.
- C는 언제나 위에서 아래로 코드를 본다. ANSI C(C89)에서 함수 정의가 등장하기 전 그 함수를 호출하면 컴파일러가 다음과 같이 가정한다.
  - 반환형은 int
  - 매개 변수는 아무 것이나 올 수 있다.
  - 따라서 나중에 컴파일러가 int가 아닌 다른 것을 반환하는 함수를 찾으면 컴파일 오류를 발생시킨다.

## 함수 정의의 문제

- 위에서 본 문제를 해결하기 위해서 그러면...호출하는 코드 위에 전부 함수를 위치시켜야 할까? 다행히 그렇지는 않다. 아래에 나오는 함수 선언이 이런 문제를 해결해 준다.

## 함수 선언

- 함수의 구현체 없이 함수 원형(prototype)만 선언해 주는 것이다.
  - 원형이란?
    - 함수의 이름
    - 반환형
    - 매개 변수들의 자료형
      - 매개 변수 이름은 없어도 된다. 단, 가독성을 위해 일반적으로 변수 이름도 넣는 게 좋다.
  - 함수 정의(definition)은 실제로 함수를 구현해놓은 것이다.
    - 당연히, 함수 정의는 함수 선언이기도 하다.

```c

/* 함수 선언과 정의를 분리 */

#include <stdio.h>

void foo(void);

int main(void)
{
    foo();
    getchar();
    return 0;
}

void foo(void)
{
    printf("foo called");
}

/* 함수 선언과 정의가 하나 */

#include <stdio.h>

void foo(void)
{
    printf("foo called");
}

int main(void)
{
    foo();
    getchar();
    return 0;
}

```

- 함수를 선언한다는 것은 함수를 사용하기 전에 그 함수를 선언한다는 것이다. 보통은 파일의 제일 위에 선언한다.
  - forward declaration(전방 선언) 이라는 표현으로 많이 쓴다.
- 또는 헤더 파일에 넣을 수도 있고 이게 더 좋은 방법이다.
- 전방 선언의 작동 원리
  - 컴파일 시 실제 어디로 가서 코드를 찾아야 하는지는 모르니 구멍으로 둔다.
  - 컴파일 다음 단계인 링크(link) 단계에서 실제 코드 위치를 찾아서 그 구멍을 채운다.
- C89 표준에서 기본적으로 가정하는 사항을 충족하는 경우(int 를 반환하는 함수)에는 함수 선언을 하지 않아도 될까?
  - 그러지 말자. 함수 선언은 언제나 하도록 하자.
  - C99 표준부터는 int라는 가정을 하지 않는다.
  - 어떤 컴파일러는 경고만 주고, 컴파일은 허용할 수도 있다.
  - 모든 컴파일러가 그렇단 보장이 없다.

## 함수 매개변수 평가 순서, 피연산자 평가 순서

- 실수할 가능성이 높은 부분이다. 주의해서 보도록 하자.

```c
#include <stdio.h>

int add(int op1, int op2)
{
    printf("add()\n");
    return op1 + op2;
}

int subtract(int op1, int op2)
{
    printf("subtract()\n");
    return op1 - op2;
}

int main(void)
{
    int num1 = 128;
    int num2 = 256;

    printf("%d, %d\n", add(num1, num2), subtract(num1, num2));

    return 0;
}

```

- 위의 코드는 어떤 순서로 출력이 될까? => 모른다.
  - 경우 1) add()가 먼저 평가
  - 경우 2) subtract()가 먼저 평가
- 표준에 따르면, 함수 매개 변수의 평가 순서는 명시되어 있지 않음(unspecificed)
  - undefined 와 unspecificed 는 다르다. unspecified는 문제에 대해 가능한 경우의 수를 정의는 해 놓는다. 단 그 경우의 수 중 어떤 것이 옳은지는 정의하지 않는다.
- 즉, 컴파일러에 따라 평가 순서가 달라질 수 있다.
- `printf()`가 실제로 실행되기 전에 `add()`와 `subtract()`가 실행가 실행되는 것은 보장된다. 단, add와 subtract 중 어떤 것이 먼저 실행될지는 보장하지 않는다. 컴파일러에 따라 다를 수 있다는 말이다.
- 따라서 같은 라인에서 왼편에 있는 함수가 먼저 실행될 것이라 가정하고 코드를 짜는 것은 버그를 유발할 수 있다.
  - 예를 들어, 두 함수가 같은 변수를 사용(read/write)하고 호출 순서에 의존적이라고 할 경우, 컴파일러에 따라 함수 실행 순서가 달라질 수 있고 의도와는 다른 결과를 만들 수 있다.

```c
#include <stdio.h>

float divide(int op1, int op2)
{
    printf("%d / %d = ", op1, op2);
    return op1 / (float) op2;
}

int main(void)
{
    int num = 0;
    float result = divide(++num, ++num);
    printf("%f\n", result);

    return 0;
}

```

- 그렇다면 위의 코드는 실행 결과가 어떻게 될까? => undefined behavior
  - 첫 번째 인자가 먼저 평가될 경우
  - 두 번째 인자가 먼저 평가될 경우
  - 동시에 평가될 수도 있다.

- 기본적으로 한 줄에서 동인한 변수를 여러 번 바꾸면 위험하다.
  - 함수 매개 변수의 평가 순서는 컴파일러마다 다를 수 있다.
  - 한 함수의 매개 변수들이 동일한 변수를 수정할 경우, 결과가 정의되지 않음(undefined behavior)
  
  ```c
  /* 위험한 것들 */
  add(++i, ++i);
  add(i = -1, i = -1);
  add(i, i++);
  ```

- 정의되지 않은 것은 하지말자. 위험하다.
- `+` 연산자는 피연산자의 평가 순서를 강제하지 않는다. `=` 연산자도 마찬가지이다.

## 연산자 우선순위와 평가 순서

```c
int main(void)
{
    int num1 = 10;
    int num2 = 20;

    int result = add(num1, num2) + subtract(num1, num2) * divide(num1, num2);
    printf("result: %d\n", result);

    return 0;
}
```

- 주의하자. 함수의 평가 순서와 연산자 우선 순위는 아무런 관련이 없다. add, subtract, divide 무엇이 먼저 평가될 지는 알 수 없다.

## 평가 순서를 강제하는 연산자

- sequence point, <https://en.wikipedia.org/wiki/Sequence_point> 에 대해 읽어보도록 하자.
- short circuit 평가도 평가 순서를 강제하는 연산자 중 하나이다.
  - 논리 연산자 &&와 ||는 평가 순서를 강제하는 연산자이다.
  - 왼쪽 피연산자의 평가만으로 오른쪽 피연산자를 평가 안 할 수 있다.
- 정리하자면, 한 줄에 있는 여러 피연산자들은 기본적으로 평가 순서가 보장 안 된다고 생각하자.
  - short circuit, 삼항 연산자 정도만 예외적으로 알아두자.

## 범위(scope)

- 블록 범위
  - 중괄호({}) 안에 선언한 것들은 그 블록 안에서만 사용 가능하다.
  - 블록 안에 또 다른 블록을 넣을 수도 있다. 그러면 안쪽 블록은 바깥 블록에는 접근이 가능하지만 그 반대는 안 된다.
    - c에서는 변수 선언 위치의 제약 때문에 블록이 조금 특별한 의미를 갖는다. 아래의 예를 보자.

    ```c
    int main(void)
    {
        int num1 = 10;
        printf("num: %d\n", num1);

        {
            /* c에서는 변수 선언 위치에 제약이 있다. 이렇게 블록 안에서 선언하면 괜찮다. */
            int num2 = 100;
            int result = num1 + num2;
            printf("result: %d\n", result);
        }

        /* num2, result 접근 못 함 */
    }

    ```

  - 변수 이름 가리기(variable shadowing) 금지. 가독성 뿐만 아니라 버그를 만들 가능성이 높다. 변수 이름 가리기는 블록 안에서 블록 밖에 있는 변수와 같은 이름의 변수를 선언하고 사용하는 것을 말한다.

  ```c
  /* 안 좋은 코드 */
  int main(void)
  {
      int num = 0;
      printf("%d", num);
      {
          int num = 1; /* variable shadowing */
          printf("%d", num);
      }

      return 0;
  }

  ```

- 파일 범위
  - 어떤 블록이나 매개 변수 목록에도 안 속하고 파일 안에 있는 것을 말한다.
  - 엄밀하게 말하면 translation unit이다. 이것에 대해서는 나중에 더 배울 것이다.

  ```c
  # include <stdio.h>

  /*  파일 범위 */
  static int s_num = 1024;

  int add(int op1, int op2);

  int main(void)
  {
      s_num = add(10, 30);

      return 0;
  }
  ```

  - 파일 범위에 있는 변수는,
    - 다른 소스코드 파일에서 링크 가능
    - 프로그램 실행 동안 공간을 차지한다.
      - 즉, 스택 메모리에 들어가는 것이 아니다.
      - 데이터 섹션에 들어간다.
  - 이게 바로 전역 변수이다.
- 함수 범위
  - 유일한 예: 레이블(label)
  - goto 같은 데서 쓰는 것이다.
  - 함수 안에서 선언된 레이블은 함수 어디에서라도 접근 가능하다.
  
  ```c
  int main(int argc, char** argv)
  {
      if (argc != 3) {
        goto exit;
      }

      printf("You have 3 arguments!");
  
  exit:
      return 0;
  }
  ```

- 함수 선언 범위
  - 함수 선언의 매개 변수 목록에 있는 것은 그 목록 안에서 접근이 가능하다.
  - 많이 쓰일 일은 없지만 알아두자.

  ```c
  /* 괜찮은 예제들 */
  void so_something(
      double value,   /* 함수 선언 범위 */
      char array[10 * sizeof(value)] /* value는 첫 번째 매개변수 */
  )
  ```

## const 키워드

- 이름 달린 상수를 만들어 주기 좋다.
- 실수를 방지하기 좋다.

```c
/* 예 1) const 때문에 밑에서 id를 바꾸려는 시도를 하면 컴파일 에러가 난다. */
int calculate_risk(const int id) 
{
  /* ... */

  id *= 2; /* 컴파일 오류 */

  /* ... */
}

/* 예 2) const 때문에 밑에서 id를 바꾸려는 시도를 하면 컴파일 에러가 난다. */
void update_dimenstion(int w, int h, int data[])
{
    const int area = w * h;

  /* ... */

    area = area + 1; /* 컴파일 오류 */

  /* ... */
}

```

- const best practice
  - 기본적으로 모든 변수에 const를 붙이자.
  - 정말 값 변경이 필요한 변수에만 const를 생략하자.

## goto 문

```c
goto <label_name>;
...

<label_name>:

```

- C는 위에서 아래로 순차적으로 코드를 실행하는 언어이다. 그런데 `goto`를 쓰면 이 순서를 어기고 다음에 실행할 코드를 마음대로 지정이 가능하다.
  - 같은 함수 내에 있는 레이블(label)로 점프한다.

- goto의 나쁜 예

```c
void do_work(void)
{
infinity:
    printf("work time!\n");

    goto infinity;
}

```

- 반복문은 결국 goto를 사용하는 코드이다.

## goto 문은 정말로 악마인가요?

- 기본적으로는 좋지 않다. 실수/버그를 만들기 쉬운 코드이기 때문이다.
- 그러나 때때로 goto를 써서 코드가 간결해지는 경우도 있다. 중첩된 for문에서 중간에 종료하고자 하는 경우, goto를 이용하면 코드가 많이 간결해진다.

```c
for (i = 0; i < DEPTH; ++i) {
    for (j = 0; j < HEIGHT; ++j) {
        for (k = 0; k < WIDTH; ++k) {
            if (data[i][j][k] == 1) {
                printf("%d", data[i][j][k]);
            }
            else {
                goto loop_exit;
            }
        }
    }
}

loop_exit:
  /* code */
```

- goto best practice
  - goto 문은 언제나 전방(아래쪽)으로만 점프할 것. 위로 점프하면 코드가 꼬이기 쉽다.
  - nested loop에서 빠져나올 때는 자유롭게 쓸 것.
  - 한 함수 안에 있는 여러 개의 조건문이 공통된 코드를 실행해야 할 때는 괜찮다.
    - 예) 함수 마지막에 성공/오류 조건 처리
  - 단, 같이 일 하는 프로젝트에서 goto를 좋아하지 않는 사람이 있다면, 안 쓰는 게 낫다.

## 배열

- 반드시 new를 사용할 필요가 없다.

```c
int nums[5];
char name[10];
float GPAs[3] = { 3.1f, 2.2f, -13.f };

```

- 접근 방법은 여타 다른 언어와 비슷하다.

## 스택 메모리

- C는 값형으로도 배열을 만들 수 있다.

### 스택 메모리란

- 자료 구조인 스택이랑 헷갈리지 말자. 작동 방법이 동일해서(LIFO) 스택이란 이름을 사용할 뿐이다.
- 각 함수에서 사용하는 지역 변수 등을 임시적으로 저장하는 공간이다.
- 스택 메모리의 크기는 프로그램 빌드 시에 결정 된다.
- 스택 메모리의 위치는 실행 시에 결정된다.
- 스택 메모리가 어떻게 쓰이는 지 좀 풀어 설명해 보자. 어떤 함수가 호출되면 그 함수 실행을 위해 메모리 공간이 필요하다. 그 때 필요한 공간을 스택에서 떼어준다(이 공간은 마음대로 쓰라고 한다). 그리고 그 함수가 종료되면 다시 그 공간의 소유를 회수한다.

- 기본 자료형 변수는 모두 스택 메모리를 차지한다.
  - Java 같은 곳에서 기본 자료형 변수(char, int, float...)를 `new` 없이 사용할 수 있었던 이유는 스택 메모리에 할당 되었기 때문이다.
  - 기본 자료형을 함수 매개 변수로 전달하면 스택에 복사본을 만든다. 이게 바로 값형이다.
  - 스택 메모리를 빌리고 반환할 때마다 언제나 빈 공간 없이 차곡차곡 쌓여 있다.
  - Java 같은 곳에서 `new` 로 만든 데이터는 힙(heap) 메모리에 할당된다.

## 스택 메모리에 대해서 간단히 알아보자

- 스택은 큰 주소에서 작은 주소로 쌓인다.
- ESP(Extended Stack Pointer): 현재 스택 포인터.
- EBP(Extended Base Pointer): 현재 스택 프레임의 기본(첫) 주소, 현재 함수가 사용하고 있는 스택 공간의 시작 부분.
- 즉, EBP ~ ESP 가 현재 내 함수가 사용하고 있는 스택 메모리 공간. 스택 프레임(Stack Frame, 각 함수가 사용하는 스택 메모리의 범위)이라고도 한다.

## 스택 메모리 안의 배열, 스택 오버플로

- 변수 대신 배열을 넣으면 어셈블리어 에선 어떻게 될까? 배열을 위한 만큼의(정확히는 조금 더 잡힐 수 있음) 메모리가 추가로 잡힌다.
- OS에서 할당해주는 메모리를 이용하는 것 보다 이렇게 스택을 사용하는 게 빠르다. 스택을 사용하면, 그냥 정해진 메모리에어 위아래로 왔다 갔다 하면 된다. 새로운 메모리를 찾아달라고 OS에게 요청할 필요가 없다.
- 스택의 크기는 한정적이지 않나?
  - 맞다.
- 쓰레드 마다 스택은 따로 생긴다. 쓰레드 별로 호출 스택이 따로 생긴다.
- 스택 오버플로우
  - 스택의 크기가 약 1MB일 때, 아래와 같은 코드를 실행하면, 곧바로 스택 오버플로우 에러가 난다.
  
  ```c
  int add(const int a, const int b)
  {
      char buffer[1024 * 1024];
      int res = a + b;
      return res;
  }

  ```

  - 너무 큰 데이터를 스택에 넣으려 하면 안 된다. 큰 데이터를 사용할 때는 동적 메모리를 할당해야 한다.
  - 재귀 함수를 너무 깊게 호출하면 스택 오버플로우가 발생할 수 있다. 함수를 한 번 호출할 때마다 그 함수의 스택 프레임만큼 바이트를 더 먹게 된다. 그 함수가 반환하지 않고 계속 다른 함수를 호출하며 스택을 올리다보면, 언젠가 스택 공간을 다 쓰게 된다. 그러다 스택 오버플로우가 발생한다.

## 배열의 요소 개수 구하는 방법

```c
int values[30];
size_t array_size = sizeof(values); /* 120 */

```

- sizeof(values)는 values 배열이 차지하는 총 바이트 수를 반환한다. 배열이 스택에서 몇 바이트를 차지하는 지 컴파일 중에 알 수 있기 때문이다.
- 배열의 요소 개수를 구하는 방법
  - 1) `const size_t num_vals = sizeof(values) / sizeof(values[0]);`
  - 2) 매크로 함수를 이용해 좀 더 쉽게 만들 수도 있다.

    ```c
    /* 함수 밖에서 */
    #define ARRAY_LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))

    /* 매크로 함수 사용 */
    const size_t num_vals2 = ARRAY_LENGTH(values);

    ```

- sizeof(매개변수)와 배열의 총 바이트 수
  - sizeof()가 매개변수로 들어온 배열의 총 바이트 수를 반환할 수 있으려면 그 배열의 모든 요소가 스택에 다 복사되어 전달되어야 한다.
  - 그리고 호출되는 함수는 스택에 복사된 모든 요소의 크기를 정확히 알 수 있어야 한다.
  - 즉 이 말은, 두 함수 호출에서 매개 변수 전달에 사용하는 스택의 크기가 달라야 한다는 말이다. 말이 안 된다.
  - 함수의 스택 메모리 사용량은 고정이다. 함수는 호출자가 누구든 간에 딱 정해진 수와 크기의 매개 변수가 들어온다는 가정으로 동작한다. 함수가 먼저 결정되는 것이고 호출자는 그 함수를 호출할 뿐이다.
  - 따라서, 배열을 매개 변수로 전달할 때는 실제 모든 요소를 스택에 넣지 않는다. 대신 그 배열의 시작 위치(주소)를 스택에 넣어 준다. sizeof(매개변수)가 4를 반환했다면, 주소의 크기(포인터 데이터 형의 크기)를 반환한 것이다.
    - 32비트 플랫폼에서는 4바이트, 64비트에서는 8바이트

## 길이가 명시된 매개변수 배열

```c
void process(int nums[5])
{
    size_t i;
    for (i = 0; i < 5; ++i)
    {
        num[i] *= 2;
    }
}

```

- 여기서 배열의 크기([5])는 그냥 프로그래머가 읽기 편하라고 [5]를 써 준 것이다.
- 컴파일하면 `void process(int nums[])`와 동일하다.

## 매개변수 배열의 길이, 배열 요소의 초기값

- 매개변수 배열의 길이를 알 수 있는 방법은 없다. 즉, 배열의 크기는 따로 기억해둬야 한다.

```c
void process(size_t n, int nums[])
{
    size_t i;
    for (i = 0; i < n; ++i)
    {
        nums[i] *= 2;
    }
}

```

- C는 배열 요소의 값을 초기화해주지 않았다. 따라서 그 전에 그 메모리에 남아있던 값을 그대로 사용한다. 이걸 초기화해주지 않고 사용하면 문제가 될 가능성이 많다. 변수도 마찬가지이다.
- 여기서 보면 C의 특징을 알 수 있다. 다른 언어와 비교했을 때 언어 자체에서 안전하라고, 또는 편의를 위해서 해주는 기능이 많이 없다. 이런 부분에서 다른 언어와 성능의 차이가 날 수 있다. 다만 유의해야 한다.
- 배열 요소를 초기화 하는 방법

```c
int nums1[4];   /* 쓰레기 값이 들어가 있음 */
int nums2[4]  = { 10, 15, 3, -1 };  /* 모두 초기화 됨 */
int nums3[4] = { 10, 15 };    /* 10, 15, 0, 0 으로 뒤는 0으로 초기화 됨 */
int nums4[2] = { 10, 15, 3 }; /* 컴파일 오류 */
int nums5[] = { 10, 15, 3}; /* 배열의 크기 = 3, 컴파일러가 배열의 크기를 결정 */

```

- 베스트 프랙틱스: 배열의 모든 값을 0으로
  - `int nums[10] = { 0, }`;
  - 가독성을 위해 0 뒤에 쉼표를 찍자.
- 초기화 안 된 지역 변수, 버퍼 오버플로 등을 유의하자.

## 다차원 배열

- 다차원 배열은 2차원이나 3차원 배열 같은 것이다.

```c
int table[2][3];
size_t i;
size_t j;

for (i = 0; i < 2; ++i)
{
    for (j = 0; j < 3; ++j)
    {
        table[i][j] = (i + 1) * (j + 1);
    }
}

```

- 아래의 두 배열은 같은 것이다. 2차원 배열은 실제로 메모리에 일렬로 배열된다.

```c
/* 1 */
int buffer[3][2];
int i;
int j;

for (i = 0; i < 3; ++i)
{
    for (j = 0; j < 2; ++j)
    {
        buffer[i][j] = 0;
    }
}

/* 2 */
int buffer[3 * 2];
int i;
int j;

for (i = 0; i < 3; ++i)
{
    for (j = 0; j < 2; ++j)
    {
        buffer[i * 2 + j] = 0;
    }
}

```

## 소스코드에서 실행파일까지, C 프로그램의 빌드 과정

- 빌드(build)란 무엇인가?
  - 사람이 읽기 쉽게 쓴 소스코드를 기계어 명령어로 변환하는 과정
  - 그리고 그 명령어들을 모아 기계에서 실행 가능한 실행 파일로 만드는 과정
- C의 빌드는 4단계로 나뉘어 있다.
  - 전처리(preprocessing)
  - 컴파일(compilation)
  - 어셈블(assembling)
  - 링크(linking)
    - 전처리, 컴파일, 어셈블을 합쳐서 컴파일이라고 부르기도 한다.

- 소스코드(.h, .c) -> `전처리기` -> 확장된 소스 코드(트랜스레이션 유닛)
- 확장된 소스 코드(트랜스레이션 유닛) -> `컴파일러` -> 어셈블리 코드
- 어셈블리 코드 -> `어셈블러` -> 오브젝트 코드
- 오브젝트 코드 -> `링커` -> 머신 코드 실행 파일(.exe, .out)

- clang에서는 한 번의 명령어로 했는데?
  - clang이 모든 4단계를 한 번에 실행해 준 것이다.
  - clang에서도 당연히 한 단계씩 따로 실행할 수 있다.

## .h와 .c 파일

### C파일(.c)

- 실제 프로그램을 돌게 하는 로직 코드를 저장해두는 파일.
- 함수의 정의, 함수의 구현, 전역 변수 매크로 등을 정의한다.

### 헤더 파일(.h)

- 여러 소스코드 파일에 공통으로 필요한 것들을 저장해두는 파일.
- 함수 선언, 매크로, extern 변수 선언 등을 포함한다.
- 사용 하려면 #include로 포함한다.

## 헤더 파일이 필요한 이유

- 모든 소스 코드를 .c 파일 하나에 집어 넣을 수도 있다. 근데 그렇게 하지 말자...
- 동일한 함수를 여러 곳에서 써야 한다면? 복붙을 해야 할까?
  - 그렇게 하지 말자...
- 헤더 파일을 사용하면 함수 선언을 여러 C 파일들에서 공유해 사용할 수 있다.

## #include <>와 #include ""

- 이 둘의 차이는 디스크 상의 어디에서 헤더파일을 찾느냐에 차이가 있다.
- <> 는 시스템 경로에서만 헤더 파일을 검색한다.
  - 보통 컴파일러가 제공하는 시스템 헤더 파일을 인클루드할 때 사용한다.
- "" 는 현재 작업 중인 디렉터리(working directory)에서 헤더 파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색한다.
  - 주로 개발자가 구현한 헤더 파일들을 인클루드 할 때 사용한다.

## 빌드 과정: 전처리 단계

- 입력으로 소스 코드(.h, .c)를 받고 확장된 소스 코드(트랜스레이션 유닛)을 만들어 내는 단계이다.
- 보통 전처리기(preprocessor)라는 별도의 프로그램이 담당한다.

  0. 입력: c 파일 하나
  1. 주석을 제거한다.
  2. 매크로를 복붙(확장)한다.
  3. 인클루드 파일들을 복붙(확장)한다.
     - 확장: `#include "헤더 파일"`을 지우고 그 자리에 헤더 파일 속에 있는 내용을 복사해다가 가져다 붙이는 것을 말한다.
  4. 출력: 확장된 소스 코드
      - 컴파일의 기본 단위인 트랜스레이션 유닛(translation unit)

## 트랜슬레이션 유닛 보는 방법

- clang 컴파일 중에 `-E` 플래그를 넣으면 된다.

## 빌드 과정: 컴파일 단계

- 확장된 소스 코드 유닛(트랜스레이션 유닛)을 받고 어셈블리 코드를 만들어내는 단계이다.
- 보통 컴파일러(compiler)가 담당한다.
- 어셈블리어는 기계어와 거의 1:1로 대응 가능한 하드웨어에 아주 가까운 언어이다.
- 그러나 음...여전히 텍스트 파일이어서 기계어에 비해선 사람이 읽기 쉬운(?..) 언어이다.
- 어셈블리어 코드는 아직 정의를 모르는 심볼을 사용할 수 있다.
  - 심볼(symbol): 함수나 변수의 이름 등
  - 이것이 바로 헤더를 통한 선언만으로 컴파일이 가능한 이유이다.
- 컴파일러가 어떤 함수나 변수의 정의를 못 찾을 경우, 선언만 보고 그 부분은 일단 구멍으로 남겨둔다.
  - 그 구멍을 메꾸는 건 나중에 링크 단계해서 해 준다.

## 어셈블리어 코드 보는 방법

- 컴파일 플래그 `-S`를 쓰면 어셈블리어 코드가 .s 파일로 저장된다.
- 어셈블리어 코드가 나왔다는 의미는 무엇일까?
  - 이 단계 이후부터 코드는 특정 플랫폼에서만 동작한다는 이야기이다.
  - C가 크로스 플랫폼이라는 주장은 컴파일되기 전 까지만이다.
  - 자료형의 크기 등도 이 단계에서 정해진다.

## 빌드 과정: 어셈블 단계

- 컴파일러가 준 어셈블리 코드를 바탕으로 오브젝트 코드를 만드는 과정이다.
- 어셈블러(assembler)라는 프로그램이 담당한다.
- 오브젝트 코드란?
  - 기계가 곧바로 이해 가능한 기계코드(machine code)
  - 기계어(machine instruction)라고도 한다.
  - 즉, 이진코드이다.
  - 어셈블리어 코드와 마찬가지로 여전히 메꿔야 하는 구멍이 있다.

## 오브젝트 코드 보는 방법

- `-c` 플래그를 넣어서 컴파일하면 .o 파일로 저장된다.
- 나온 파일을 16진수 편집기로 열어볼 수 있다. 열어 보면 구멍이 뚫린 부분이 아직 남아있는 걸 확인할 수 있다.

## 빌드 과정: 링크 단계

- 오브젝트 코드를 입력으로 받아 실행 파일을 만드는 단계이다.
- 링커(linker)라는 프로그램이 담당한다.
- 입력이 더이상 파일 한 개가 아니다. 모든 오브젝트 코드들이다. 링커는 모든 오브젝트 코드들을 모아다 구멍을 메꾼 뒤 실행파일로 저장한다.
- 그럼 링커는 어떻게 구멍을 메울까?
  - 링커가 오브젝트 파일을 다 모아서 하나의 이진(binary)파일로 만들어 주다가 주어진 함수의 위치를 기억하고 있는다.
  - 함수를 호출하려는 코드를 만나면 실행 위치에 아까 그 위치(주소)로 점프하는 코드를 넣어준다.
  - 따라서, 선언만 믿고 사용한 함수나 변수가 여전히 구멍으로 남아 있다면,
    - 링커가 못 찾는다면 링커가 오류를 뱉는다. 중요한 건 단순 경고가 아니라 오류가 발생한다는 것이다.

## 링크 단계가 분리되어 있는 이유

- 사람들은 보통 빌드 과정을 컴파일(처음 세 단계)와 링크, 즉 두 단계로 분리해서 생각한다. 왜 굳이 링크 단계가 분리되어 있을까? 굳이 합치지 않은 이유가 뭘까?
  - .c 파일이 많이 있으면 구멍을 메꿔주는 일이 매우 복잡하다. 예를 들어, .c 수 천개나 있는 프로젝트에서 .c 파일 하나 컴파일 할 때마다 모든 함수를 찾아서 구멍을 메꿔줘야 하나?
  - 여러 개의 .c 파일에서 동일한 외부 함수를 사용할 경우 최종 실행 파일에 그 함수 정의가 중복으로 들어가는 것도 막아야 한다. 링크 단계를 분리하지 않으면 중복을 어떻게 해결할 방법이 없다.
- 결과적으로는 .c 파일 하나씩 따로 컴파일해서 오브젝트 파일로 저장해두는 방법이 낫다.
  - 나중에 바뀐 .c 파일만 컴파일해서 새로운 오브젝트 파일을 생성한다.
  - 그리고 기존에 있던 오브젝트 파일들과 합쳐서 링크한다. 이런 방식이 훨씬 빠르다.
  - 그리고 분리시켜 놓으니 간단해지고 좋다. 각자 할 일이 확실히 분리된다.
- 어떻게 .o 파일을 실행 파일로 만들까?
  - `clang -std=c89 -W -Wall -pedantic-errors *.o`

## 라이브러리(library), 정적/동적 라이브러리와 링크

- 라이브러리(library)란?
  - 위에서 본 함수 등을 기계어로 변환 후 파일 하나로 저장해 놓은 것이다.
  - 나중에 다른 .c 파일에서 이 기능이 필요할 때 같이 링크해서 쓸 수 있다.
  - 라이브러리에는 두 종류가 있다.
    - 정적(static) 라이브러리
    - 동적(dynamic) 라이브러리
- 정적 라이브러리와 링크
  - 정적 라이브러리와 링크하는 것을 정적 링킹이라고 한다.
  - 라이브러리 안에 있는 기계어를 최종 실행 파일에 가져다 복사한다.
  - 동적 링킹에 비해
    - 실행 파일의 크기가 커진다.
    - 메모리를 더 잡아먹을 수 있다.
    - 그러나 실행 속도가 더 빠르다.  
- 동적 라이브러리와 링크
  - 동적 라이브러리와 링크하는 것을 동적 링킹이라고 한다.
  - 실행 파일 안에 여전히 구멍을 남겨두는 방법이다.
  - 실행 파일을 실행할 때 실제로 링킹이 일어난다.
    - 이 링킹은 실행 중에 운영체제가 해준다.
  - .dll 파일이 dynamic link library 이다. 이게 동적 링크 라이브러리이다.
  - 정적 링킹에 비해
    - 실행 파일 크기가 작다.
    - 여러 실행 파일이 동일한 라이브러리를 공유할 수 있다 -> 메모리를 절약할 수 있다.
    - 다만, 여러 실행 파일이 이름은 같지만 버전이 다른 동적 라이브러리를 사용한다면 DLL 지옥(DLL Hell)을 맞볼 수 있다.

## 분할 컴파일과 전역 변수

- 분할 컴파일
  - 2개 이상의 .c 파일을 개별적으로 컴파일해서 오브젝트 파일들을 만든다.
  - 오브젝트 파일들을 서로 연결시켜(링크해서) 실행 파일을 만든다.

## 다른 파일에 있는 전역 변수 사용 시 문제점

다음과 같은 파일들이 있다고 하자. 무엇이 문제일까?

- monster_repo.h

  ```c
  void add_monster(void);

  ```

- monster_repo.c

  ```c
  #include "monster_repo.h"

  int g_mob_count = 0;

  void add_monster(void)
  {
      ++g_mob_count;
  }

  ```

- main.c

  ```c
  #include <stdio.h>
  #include "monster_repo.h"

  int main(void)
  {
      add_monster();
      printf("# monsters: %d\n", g_mob_count);

      return 0;
  }

  ```

- 위 코드를 실행해 보면 `g_mob_count` 가 선언되지 않았다고 나온다. 왜 컴파일 오류가 날까?
  - 컴퍼알리가 각 .c 따로따로 컴파일 하기 때문이다. 따라서 main.c 파일은 monster_repo.c 안에 있는 g_mob_count의 존재를 알 수 없다.
- 어떻게 고칠 수 있을까?
  - main 에 `g_mob_count` 를 선언해주면? 변수 이름 중복 문제 때문에 링킹 과정에서 문제가 발생한다.
  - 따라서 새로운 전역 변수를 만드는 것이 아니라 monster_repo.c 안에 있는 것을 가져다 쓸 것이라고 컴파일러에게 말해주어야 한다. 마치 함수 전방 선언을 해뒀던 것과 비슷한 개념이다.

## extern 키워드

- 위의 예에서 monster_repo.h 를 아래와 같이 고칠 수 있다.

  ```c
  extern int_g_mob_count;
  void add_monster(void);

  ```

- 또는 main.c 에서 `extern int g_mob_count;` 를 선언해준 뒤 사용할 수도 있다. 이 방법은, 이 변수가 main.c 에서만 쓰이길 원할 경우에 사용할 수 있는 방법이다.
- extern 키워드
  - 다른 파일에 있는 전역 변수에 접근하려면 `extern` 키워드를 사용한다.
- extern을 사용하려면 .c 파일을 일일이 열어서 전역 변수를 사용해야 할까?
  - 그래도 된다. 그런데 어떤 경우엔 .c 파일을 볼 수 없을 수도 있다.
  - 이런 경우 라이브러리 제작자가 extern을 아예 헤더에 포함시켜 준다. 그게 아니라면 보통은 못 쓴다.
  - 여전히 사용하는 c 파일 안에 직접 extern을 넣는 경우가 많다.
  - 헤더에 넣는 것 vs c 파일에 넣는 것
    - 헤더에 넣는 것은 누구라도 쓸 수 있게 해주는 것이다.
    - c 파일에 넣는 것은 그 파일 안에서만 쓰려고 하는 것이다.
- 실수로 헤더에 다음과 같이 `extern` 을 빼고 넣어도 변수 중복 문제가 발생한다 왜 그럴까?
  - monster_repo.h

  ```c
  int g_mob_count = 0;
  void add_monster(void);

  ```

  - 컴파일 과정에서 include가 복붙되기 때문이다. 즉 오브젝트 코드엔 두 번 나오게 된다.

## 전역 변수의 문제, static 키워드

- 전역 변수엔 확실히 문제가 있다.
  - `extern` 을 사용하면 아무데서나 다 확인이 가능하다.
  - 심지어는 자기 마음대로 내 파일 안의 변수를 바꿔버린다.
- 내 파일 안에서만 전역 변수를 사용 가능하게 하려면 어떻게 해야할까? 전역 변수를 만들 때 `static` 키워드를 붙여주면 된다.

  - monster_repo.c

    ```c
    #include "monster_repo.h"

    static int s_mob_count = 0;

    void add_monster(void)
    {
        ++s_mob_count;
    }

    ```

- static 키워드
  - 다른 파일에서 전역 변수에 접근을 못 하게 막는 키워드이다.
  - 이 변수의 범위가 파일로 한정 된다.
  - static 키워드가 붙은 변수를 흔히 정적 변수라고 한다.
  - 여전히 전역 변수로 프로그램 실행 동안에 실제 공간을 계속 차지하고 있다.
  - static 변수를 다른 파일에서 접근하려고 하면 링커 오류가 발생한다.

- static 키워드의 다른 예

  ```c
  #include "monster_repo.h"

  void add_monster(void)
  {
      static int s_mob_count = 0;
      ++s_mob_count;
  }

  ```

  - 함수 안에 있는 변수이다. 그런데 마치 전역 변수 처럼, 함수가 끝나도 계속 남아 있다.
  - static이 붙으면 지역 변수가 전역 변수처럼 프로그램의 실행 동안 계속 생명이 유지된다.
  - 즉 stack에 생성되는 변수가 아니다.
  - 함수 안에 static 변수가 선언되어 있으면, 접근 범위가 함수 안으로만 제한된다.
  - 함수는? 함수도 앞에 static 키워드를 넣으면 외부로부터의 접근을 막을 수 있다.

## .c와 .h 파일 정리, 순환 헤더 인클루드와 해결법

- 빌드의 4단계가 올바르게 돌게 하려면 아래의 기본 원칙을 따라야 한다.
  - 헤더 파일에는 선언만 들어간다.
    - 함수 선언
    - 전역 변수 extern 선언
  - .c 파일에는 정의가 들어간다.
    - 함수 정의
    - 전역 및 정적 변수 정의
- 순환 헤더 인클루드(circular header include)
  - 헤더 a가 헤더 b를 인클루드 하고 헤더 b가 헤더 a를 인클루드 하는 것과 같은 일을 말한다.
  - 해결법 1: 이런 상황을 최대한 피할 것
    - #include는 가능하면 .c에서만 하기
    - b 헤더에서 a 헤더를 인클루드 하는 대신 a에서 정의된 것을 전방 선언하기
    - 하지만 어쩔 수 없이 헤더 파일을 서로 인클루드 해야 할 수 있다.
  - 해결법 2: 인클루드 가드(guard)
    - c에서 헤더 파일이 여러 번 인클루드 되는 것을 막는 업계 표준

      ```c
      /* foo.h */
      #ifndef FOO_H
      #define FOO_H
      /* 헤더 파일 내용 */ 
      #endif /* FOO_H */

      ```

    - #으로 시작하면, 전처리기 지시문이다. #include 말고도 다양한 것이 있다.
    - 일단 #define, #ifndef, #endif 만 써보자.

## 인클루드 가드 작동법

- 전처리기 지시문은 코드를 컴파일하기 전에 전처리기가 처리한다.
  - `#ifndef FOO_H`: 만약 FOO_H가 정의되지 않았다면,
  - `#define FOO_H`: FOO_H를 정의할 것
  - `#endif /* FOO_H */`: #ifndef 블록의 끝, 보통 파일 이름을 주석으로 같이 넣는다.
- 언제나 인클루드 가드를 써야한다고 생각하자.

## C 컴파일러의 종류와 특징

- GCC (GNU Compiler Collection)
  - GNU C 컴파일러는 1987년에 첫 출시
  - 리눅스/유닉스 기반 플랫폼에서 주로 사용되던 컴파일러
  - 다양한 C 표준을 대부분 제대로 지원
- 마이크로소프트 Visual C++
  - 원래 비주얼 스튜디오에 딸려오는 C++ 컴파일러이나 확장자가 .c일 경우 C로 컴파일
  - C99 표준, 그러나 모든 표준을 지키지는 않는다.
  - C11의 대부분을 지원하지 않는다.
  - 윈도우 기반 플랫폼에선 이것을 주로 사용한다.
- Clang
  - LLVM 컴파일러 구조를 사용하는 C계열 언어(C++, Objective-C/C++, OpenCL, CUDA 등) 컴파일러 프론트엔드
  - 원래 애플 사가 개발했다.
    - 2007년에 오픈 소스가 된 뒤 마이크로소프트, 구글 등 다양한 대기업들이 개발에 참여
  - gcc 컴파일러 대신 Clang을 쓰면 코드 변경 거의 없이 그대로 컴파일 되고 빠른 컴파일 속도와 LLVM 구조가 제공하는 유용한 기능 덕에 많은 gcc 사용자들이 Clang으로 이주 중.
  - clang-ci라는 비주얼 C와 호환되는 프론트엔드도 제공
